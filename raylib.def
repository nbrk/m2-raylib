(*
    Title:     Modula-2 direct bindings to the excellent Raylib.
    Created:   Mon Feb 12 19:19:31 2024
    Author:    Nikolay A. Burkov <nbrk@linklevel.net>
 *)
DEFINITION MODULE FOR "C" raylib;

IMPORT SYSTEM;

TYPE
   Int = SYSTEM.INTEGER32;
   Short = SYSTEM.INTEGER16;
   Long = SYSTEM.INTEGER64;
   Unsigned = SYSTEM.CARDINAL32;
   Float = SYSTEM.REAL32;
   Double = SYSTEM.REAL64;
   Unsigned8 = SYSTEM.CARDINAL8;

   ADDRESS = SYSTEM.ADDRESS;

   Vector2 = RECORD
      x, y : Float;
   END (* record *);

   Vector3 = RECORD
      x, y, z : Float;
   END (* record *);

   Vector4 = RECORD
      x, y, z, w : Float;
   END (* record *);

   Quaternion = Vector4;

   Matrix = RECORD
      m0, m4, m8, m12 : Float;
      m1, m5, m9, m13 : Float;
      m2, m6, m10, m14 : Float;
      m3, m7, m11, m15 : Float;
   END (* record *);

   Color = RECORD
      r,g,b,a : Unsigned8;
   END;


   Rectangle = RECORD
      x,y, width, height : Float;
   END;

   Image = RECORD
      data : ADDRESS;
      width, height, mipmaps, format : Int;
   END;

   Texture = RECORD
      id : Unsigned;
      width, height, mipmaps, format : Int;
   END;

   Texture2D = Texture;

   TextureCubemap = Texture;

   RenderTexture = RECORD
      id : Unsigned;
      texture : Texture;
      depth : Texture;
   END;

   RenderTexture2D = RenderTexture;

   NPatchInfo = RECORD
      source : Rectangle;
      left, top, right, bottom, layout : Int;
   END;

    GlyphInfo = RECORD
       value, offsetX, offsetY, advanceX : Int;
       image : Image;
    END;

    Font = RECORD
       baseSize, glyphCount, glyphPadding : Int;
       texture : Texture2D;
       recs : POINTER TO Rectangle;
       glyphs: POINTER TO GlyphInfo;
    END;

    Camera3D = RECORD
       position, target, up : Vector3;
       fovy : Float;
       projection : Int;
    END;

    Camera = Camera3D;

    Camera2D = RECORD
       offset, target : Vector2;
       rotation, zoom : Float;
    END;

(* // Mesh, vertex data and vao/vbo *)
(* typedef struct Mesh { *)
(*     int vertexCount;        // Number of vertices stored in arrays *)
(*     int triangleCount;      // Number of triangles stored (indexed or not) *)

(*     // Vertex attributes data *)
(*     float *vertices;        // Vertex position (XYZ - 3 components per vertex) (shader-location = 0) *)
(*     float *texcoords;       // Vertex texture coordinates (UV - 2 components per vertex) (shader-location = 1) *)
(*     float *texcoords2;      // Vertex texture second coordinates (UV - 2 components per vertex) (shader-location = 5) *)
(*     float *normals;         // Vertex normals (XYZ - 3 components per vertex) (shader-location = 2) *)
(*     float *tangents;        // Vertex tangents (XYZW - 4 components per vertex) (shader-location = 4) *)
(*     unsigned char *colors;      // Vertex colors (RGBA - 4 components per vertex) (shader-location = 3) *)
(*     unsigned short *indices;    // Vertex indices (in case vertex data comes indexed) *)

(*     // Animation vertex data *)
(*     float *animVertices;    // Animated vertex positions (after bones transformations) *)
(*     float *animNormals;     // Animated normals (after bones transformations) *)
(*     unsigned char *boneIds; // Vertex bone ids, max 255 bone ids, up to 4 bones influence by vertex (skinning) *)
(*     float *boneWeights;     // Vertex bone weight, up to 4 bones influence by vertex (skinning) *)

(*     // OpenGL identifiers *)
(*     unsigned int vaoId;     // OpenGL Vertex Array Object id *)
(*     unsigned int *vboId;    // OpenGL Vertex Buffer Objects id (default vertex data) *)
(* } Mesh; *)
    Mesh = RECORD
       vertexCount, triangleCount : Int;
       vertices, texcoords, texcoords2, normals, tangents : POINTER TO Float;
       colors : POINTER TO Unsigned8;
       indices : POINTER TO Short;
       animVertices, animNormals : POINTER TO Float;
       boneIds : POINTER TO Unsigned8;
       boneWeights : POINTER TO Float;
       vaoId : Unsigned;
       vboId : POINTER TO Unsigned;
    END;


    Shader = RECORD
       id : Unsigned;
       locs : ADDRESS;
       END;

(* // MaterialMap *)
(* typedef struct MaterialMap { *)
(*     Texture2D texture;      // Material map texture *)
(*     Color color;            // Material map color *)
(*     float value;            // Material map value *)
(* } MaterialMap; *)
    MaterialMap = RECORD
       texture : Texture2D;
       color : Color;
       value : Float;
    END;

(* // Material, includes shader and maps *)
(* typedef struct Material { *)
(*     Shader shader;          // Material shader *)
(*     MaterialMap *maps;      // Material maps array (MAX_MATERIAL_MAPS) *)
(*     float params[4];        // Material generic parameters (if required) *)
(* } Material; *)
    Material = RECORD
       shader : Shader;
       maps : POINTER TO MaterialMap;
       params : ARRAY [0..3] OF Float;
    END;

    Transform = RECORD
       translation : Vector3;
       rotation : Quaternion;
       scale : Vector3;
    END;

(* // Bone, skeletal animation bone *)
(* typedef struct BoneInfo { *)
(*     char name[32];          // Bone name *)
(*     int parent;             // Bone parent *)
(* } BoneInfo; *)
    BoneInfo = RECORD
       name : ARRAY [0..31] OF CHAR;
       parent : Int;
    END;

(* // Model, meshes, materials and animation data *)
(* typedef struct Model { *)
(*     Matrix transform;       // Local transform matrix *)

(*     int meshCount;          // Number of meshes *)
(*     int materialCount;      // Number of materials *)
(*     Mesh *meshes;           // Meshes array *)
(*     Material *materials;    // Materials array *)
(*     int *meshMaterial;      // Mesh material number *)
(*     // Animation data *)
(*     int boneCount;          // Number of bones *)
(*     BoneInfo *bones;        // Bones information (skeleton) *)
(*     Transform *bindPose;    // Bones base transformation (pose) *)
(* } Model; *)
    Model = RECORD
       transform : Matrix;
       meshCount, materialCount : Int;
       meshes : POINTER TO Mesh;
       materials : POINTER TO Material;
       meshMaterial : POINTER TO Int;
       boneCount : Int;
       bones : POINTER TO BoneInfo;
       bindPose : Transform;
    END;

(* // ModelAnimation *)
(* typedef struct ModelAnimation { *)
(*     int boneCount;          // Number of bones *)
(*     int frameCount;         // Number of animation frames *)
(*     BoneInfo *bones;        // Bones information (skeleton) *)
(*     Transform **framePoses; // Poses array by frame *)
(*     char name[32];          // Animation name *)
(* } ModelAnimation; *)
    ModelAnimation = RECORD
       boneCount, frameCount : Int;
       bones : POINTER TO BoneInfo;
       framePoses : POINTER TO POINTER TO Transform;
       name : ARRAY [0..31] OF CHAR;
    END;

    Ray = RECORD
       position, direction : Vector3;
    END;

(* // RayCollision, ray hit information *)
(* typedef struct RayCollision { *)
(*     bool hit;               // Did the ray hit something? *)
(*     float distance;         // Distance to the nearest hit *)
(*     Vector3 point;          // Point of the nearest hit *)
(*     Vector3 normal;         // Surface normal of hit *)
(* } RayCollision; *)
    RayCollision = RECORD
       hit : BOOLEAN;
       distance : Float;
       point, normal : Vector3;
    END;

(* // BoundingBox *)
(* typedef struct BoundingBox { *)
(*     Vector3 min;            // Minimum vertex box-corner *)
(*     Vector3 max;            // Maximum vertex box-corner *)
(* } BoundingBox; *)
    BoundingBox = RECORD
       min, max : Vector3;
    END;

(* // Wave, audio wave data *)
(* typedef struct Wave { *)
(*     unsigned int frameCount;    // Total number of frames (considering channels) *)
(*     unsigned int sampleRate;    // Frequency (samples per second) *)
(*     unsigned int sampleSize;    // Bit depth (bits per sample): 8, 16, 32 (24 not supported) *)
(*     unsigned int channels;      // Number of channels (1-mono, 2-stereo, ...) *)
(*     void *data;                 // Buffer data pointer *)
(* } Wave; *)
    Wave = RECORD
       frameCount, sampleRate, sampleSize, channels : Unsigned;
       data : ADDRESS;
    END;

(* // Opaque structs declaration *)
(* // NOTE: Actual structs are defined internally in raudio module *)
(* typedef struct rAudioBuffer rAudioBuffer; *)
(* typedef struct rAudioProcessor rAudioProcessor; *)

(* // AudioStream, custom audio stream *)
(* typedef struct AudioStream { *)
(*     rAudioBuffer *buffer;       // Pointer to internal data used by the audio system *)
(*     rAudioProcessor *processor; // Pointer to internal data processor, useful for audio effects *)

(*     unsigned int sampleRate;    // Frequency (samples per second) *)
(*     unsigned int sampleSize;    // Bit depth (bits per sample): 8, 16, 32 (24 not supported) *)
(*     unsigned int channels;      // Number of channels (1-mono, 2-stereo, ...) *)
(* } AudioStream; *)
    AudioStream = RECORD
       buffer : ADDRESS;
       processor : ADDRESS;
       sampleRate, sampleSize, channels : Unsigned;
    END;

(* // Sound *)
(* typedef struct Sound { *)
(*     AudioStream stream;         // Audio stream *)
(*     unsigned int frameCount;    // Total number of frames (considering channels) *)
(* } Sound; *)
    Sound = RECORD
       stream : AudioStream;
       frameCount : Unsigned;
    END;

(* // Music, audio stream, anything longer than ~10 seconds should be streamed *)
(* typedef struct Music { *)
(*     AudioStream stream;         // Audio stream *)
(*     unsigned int frameCount;    // Total number of frames (considering channels) *)
(*     bool looping;               // Music looping enable *)

(*     int ctxType;                // Type of music context (audio filetype) *)
(*     void *ctxData;              // Audio context data, depends on type *)
(* } Music; *)
    Music = RECORD
       stream : AudioStream;
       frameCount : Unsigned;
       looping : BOOLEAN;
       ctxType : Int;
       ctxData : ADDRESS;
    END;

(* // VrDeviceInfo, Head-Mounted-Display device parameters *)
(* typedef struct VrDeviceInfo { *)
(*     int hResolution;                // Horizontal resolution in pixels *)
(*     int vResolution;                // Vertical resolution in pixels *)
(*     float hScreenSize;              // Horizontal size in meters *)
(*     float vScreenSize;              // Vertical size in meters *)
(*     float eyeToScreenDistance;      // Distance between eye and display in meters *)
(*     float lensSeparationDistance;   // Lens separation distance in meters *)
(*     float interpupillaryDistance;   // IPD (distance between pupils) in meters *)
(*     float lensDistortionValues[4];  // Lens distortion constant parameters *)
(*     float chromaAbCorrection[4];    // Chromatic aberration correction parameters *)
(* } VrDeviceInfo; *)
    VrDeviceInfo = RECORD
       hResolution : Int;
       vResolution : Int;
       hScreenSize : Float;
       vScreenSize : Float;
       eyeToScreenDistance : Float;
       lensSeparationDistance : Float;
       InterpupillaryDistance : Float;
       lensDistortionValues : ARRAY [0..3] OF Float;
       chromaAbCorrection : ARRAY [0..3] OF Float;
    END;

    VrStereoConfig = RECORD
       projection : ARRAY [0..1] OF Matrix;
       viewOffset : ARRAY [0..1] OF Matrix;
       leftLensCenter, rightLensCenter,
       leftScreenCenter, rightScreenCenter,
       scale, scaleIn : ARRAY [0..1] OF Float;
    END;

(* // File path list *)
(* typedef struct FilePathList { *)
(*     unsigned int capacity;          // Filepaths max entries *)
(*     unsigned int count;             // Filepaths entries count *)
(*     char **paths;                   // Filepaths entries *)
(* } FilePathList; *)
    FilePathList = RECORD
       capacity, count : Unsigned;
       paths : ADDRESS;
    END;

(* // Automation event *)
(* typedef struct AutomationEvent { *)
(*     unsigned int frame;             // Event frame *)
(*     unsigned int type;              // Event type (AutomationEventType) *)
(*     int params[4];                  // Event parameters (if required) *)
(* } AutomationEvent; *)
    AutomationEvent = RECORD
       frame, type : Unsigned;
       params: ARRAY [0..3] OF Int;
    END;

(* // Automation event list *)
(* typedef struct AutomationEventList { *)
(*     unsigned int capacity;          // Events max entries (MAX_AUTOMATION_EVENTS) *)
(*     unsigned int count;             // Events entries count *)
(*     AutomationEvent *events;        // Events entries *)
(* } AutomationEventList; *)
    AutomationEventList = RECORD
       capacity, count : Unsigned;
       events : POINTER TO AutomationEvent;
    END;

  (* AudioCallback = POINTER TO PROCEDURE (ADDRESS; Unsigned); *)
  (* AudioCallback = PROCEDURE(ADDRESS; Unsigned); *)

  (* AudioCallback = PROCEDURE(bufferData:ADDRESS; frames:Unsigned); *)
  AudioCallback = ADDRESS;


(* This is a test *)

(* Window-related PROCEDUREs *)

PROCEDURE InitWindow(width:Int; height:Int; title:ARRAY OF CHAR);
(* Initialize window and OpenGL context *)

PROCEDURE CloseWindow;
(* Close window and unload OpenGL context *)

PROCEDURE WindowShouldClose():BOOLEAN;
(* Check if application should close (KEY_ESCAPE pressed or windows close icon clicked) *)

PROCEDURE IsWindowReady() :BOOLEAN;
(* Check if window has been initialized successfully *)

PROCEDURE IsWindowFullscreen():BOOLEAN;
(* Check if window is currently fullscreen *)

PROCEDURE IsWindowHidden():BOOLEAN;
(* Check if window is currently hidden (only PLATFORM_DESKTOP) *)

PROCEDURE IsWindowMinimized():BOOLEAN;
(* Check if window is currently minimized (only PLATFORM_DESKTOP) *)

PROCEDURE IsWindowMaximized():BOOLEAN;
(* Check if window is currently maximized (only PLATFORM_DESKTOP) *)

PROCEDURE IsWindowFocused():BOOLEAN;
(* Check if window is currently focused (only PLATFORM_DESKTOP) *)

PROCEDURE IsWindowResized():BOOLEAN;
(* Check if window has been resized last frame *)

PROCEDURE IsWindowState(flag:Unsigned):BOOLEAN;
(* Check if one specific window flag is enabled *)

PROCEDURE SetWindowState(flags:Unsigned);
(* Set window configuration state using flags (only PLATFORM_DESKTOP) *)

PROCEDURE ClearWindowState(flags:Unsigned);
(* Clear window configuration state flags *)

PROCEDURE ToggleFullscreen;
(* Toggle window state: fullscreen/windowed (only PLATFORM_DESKTOP) *)

PROCEDURE ToggleBorderlessWindowed;
(* Toggle window state: borderless windowed (only PLATFORM_DESKTOP) *)

PROCEDURE MaximizeWindow;
(* Set window state: maximized, if resizable (only PLATFORM_DESKTOP) *)

PROCEDURE MinimizeWindow;
(* Set window state: minimized, if resizable (only PLATFORM_DESKTOP) *)

PROCEDURE RestoreWindow;
(* Set window state: not minimized/maximized (only PLATFORM_DESKTOP) *)

PROCEDURE SetWindowIcon(image:Image);
(* Set icon for window (single image, RGBA 32bit, only PLATFORM_DESKTOP) *)

PROCEDURE SetWindowIcons(images: ADDRESS; count:Int);
(* Set icon for window (multiple images, RGBA 32bit, only PLATFORM_DESKTOP) *)

PROCEDURE SetWindowTitle(title:ARRAY OF CHAR);
(* Set title for window (only PLATFORM_DESKTOP and PLATFORM_WEB) *)

PROCEDURE SetWindowPosition(x:Int; y:Int);
(* Set window position on screen (only PLATFORM_DESKTOP) *)

PROCEDURE SetWindowMonitor(monitor:Int);
(* Set monitor for the current window *)

PROCEDURE SetWindowMinSize(width:Int; height:Int);
(* Set window minimum dimensions (for FLAG_WINDOW_RESIZABLE) *)

PROCEDURE SetWindowMaxSize(width:Int; height:Int);
(* Set window maximum dimensions (for FLAG_WINDOW_RESIZABLE) *)

PROCEDURE SetWindowSize(width:Int; height:Int);
(* Set window dimensions *)

PROCEDURE SetWindowOpacity(opacity:Float);
(* Set window opacity [0.0f..1.0f] (only PLATFORM_DESKTOP) *)

PROCEDURE SetWindowFocused;
(* Set window focused (only PLATFORM_DESKTOP) *)

PROCEDURE GetWindowHandle():ADDRESS;
(* Get native window handle *)

PROCEDURE GetScreenWidth():Int;
(* Get current screen width *)

PROCEDURE GetScreenHeight():Int;
(* Get current screen height *)

PROCEDURE GetRenderWidth():Int;
(* Get current render width (it considers HiDPI) *)

PROCEDURE GetRenderHeight():Int;
(* Get current render height (it considers HiDPI) *)

PROCEDURE GetMonitorCount():Int;
(* Get number of connected monitors *)

PROCEDURE GetCurrentMonitor():Int;
(* Get current connected monitor *)

PROCEDURE GetMonitorPosition(monitor:Int):Vector2;
(* Get specified monitor position *)

PROCEDURE GetMonitorWidth(monitor:Int):Int;
(* Get specified monitor width (current video mode used by monitor) *)

PROCEDURE GetMonitorHeight(monitor:Int):Int;
(* Get specified monitor height (current video mode used by monitor) *)

PROCEDURE GetMonitorPhysicalWidth(monitor:Int):Int;
(* Get specified monitor physical width in millimetres *)

PROCEDURE GetMonitorPhysicalHeight(monitor:Int):Int;
(* Get specified monitor physical height in millimetres *)

PROCEDURE GetMonitorRefreshRate(monitor:Int):Int;
(* Get specified monitor refresh rate *)

PROCEDURE GetWindowPosition():Vector2;
(* Get window position XY on monitor *)

PROCEDURE GetWindowScaleDPI():Vector2;
(* Get window scale DPI factor *)

PROCEDURE GetMonitorName(monitor:Int):ADDRESS;
(* Get the human-readable, UTF-8 encoded name of the specified monitor *)

PROCEDURE SetClipboardText(text:ARRAY OF CHAR);
(* Set clipboard text content *)

PROCEDURE GetClipboardText():ADDRESS;
(* Get clipboard text content *)

PROCEDURE EnableEventWaiting;
(* Enable waiting for events on EndDrawing(), no automatic event polling *)

PROCEDURE DisableEventWaiting;
(* Disable waiting for events on EndDrawing(), automatic events polling *)

(* Cursor-related PROCEDUREs *)

PROCEDURE ShowCursor;
(* Shows cursor *)

PROCEDURE HideCursor;
(* Hides cursor *)

PROCEDURE IsCursorHidden():BOOLEAN;
(* Check if cursor is not visible *)

PROCEDURE EnableCursor;
(* Enables cursor (unlock cursor) *)

PROCEDURE DisableCursor;
(* Disables cursor (lock cursor) *)

PROCEDURE IsCursorOnScreen():BOOLEAN;
(* Check if cursor is on the screen *)

(* Drawing-related PROCEDUREs *)

PROCEDURE ClearBackground(color:Color);
(* Set background color (framebuffer clear color) *)

PROCEDURE BeginDrawing;
(* Setup canvas (framebuffer) to start drawing *)

PROCEDURE EndDrawing;
(* End canvas drawing and swap buffers (double buffering) *)

PROCEDURE BeginMode2D(camera:Camera2D);
(* Begin 2D mode with custom camera (2D) *)

PROCEDURE EndMode2D;
(* Ends 2D mode with custom camera *)

PROCEDURE BeginMode3D(camera:Camera3D);
(* Begin 3D mode with custom camera (3D) *)

PROCEDURE EndMode3D;
(* Ends 3D mode and returns to default 2D orthographic mode *)

PROCEDURE BeginTextureMode(target:RenderTexture2D);
(* Begin drawing to render texture *)

PROCEDURE EndTextureMode;
(* Ends drawing to render texture *)

PROCEDURE BeginShaderMode(shader:Shader);
(* Begin custom shader drawing *)

PROCEDURE EndShaderMode;
(* End custom shader drawing (use default shader) *)

PROCEDURE BeginBlendMode(mode:Int);
(* Begin blending mode (alpha, additive, multiplied, subtract, custom) *)

PROCEDURE EndBlendMode;
(* End blending mode (reset to default: alpha blending) *)

PROCEDURE BeginScissorMode(x:Int; y:Int; width:Int; height:Int);
(* Begin scissor mode (define screen area for following drawing) *)

PROCEDURE EndScissorMode;
(* End scissor mode *)

PROCEDURE BeginVrStereoMode(config:VrStereoConfig);
(* Begin stereo rendering (requires VR simulator) *)

PROCEDURE EndVrStereoMode;
(* End stereo rendering (requires VR simulator) *)

(* VR stereo config PROCEDUREs for VR simulator *)

PROCEDURE LoadVrStereoConfig(device:VrDeviceInfo):VrStereoConfig;
(* Load VR stereo config for VR simulator device parameters *)

PROCEDURE UnloadVrStereoConfig(config:VrStereoConfig);
(* Unload VR stereo config *)

(* Shader management PROCEDUREs *)

(* NOTE: Shader PROCEDUREality is not available on OpenGL 1.1 *)

PROCEDURE LoadShader(vsFileName:ARRAY OF CHAR; fsFileName:ARRAY OF CHAR):Shader;
(* Load shader from files and bind default locations *)

PROCEDURE LoadShaderFromMemory(vsCode:ARRAY OF CHAR; fsCode:ARRAY OF CHAR):Shader;
(* Load shader from code strings and bind default locations *)

PROCEDURE IsShaderReady(shader:Shader):BOOLEAN;
(* Check if a shader is ready *)

PROCEDURE GetShaderLocation(shader:Shader; uniformName:ARRAY OF CHAR):Int;
(* Get shader uniform location *)

PROCEDURE GetShaderLocationAttrib(shader:Shader; attribName:ARRAY OF CHAR):Int;
(* Get shader attribute location *)

PROCEDURE SetShaderValue(shader:Shader; locIndex:Int; value:ADDRESS; uniformType:Int);
(* Set shader uniform value *)

PROCEDURE SetShaderValueV(shader:Shader; locIndex:Int; value:ADDRESS; uniformType:Int; count:Int);
(* Set shader uniform value vector *)

PROCEDURE SetShaderValueMatrix(shader:Shader; locIndex:Int; mat:Matrix);
(* Set shader uniform value (matrix 4x4) *)

PROCEDURE SetShaderValueTexture(shader:Shader; locIndex:Int; texture:Texture2D);
(* Set shader uniform value for texture (sampler2d) *)

PROCEDURE UnloadShader(shader:Shader);
(* Unload shader from GPU memory (VRAM) *)

(* Screen-space-related PROCEDUREs *)

PROCEDURE GetMouseRay(mousePosition:Vector2; camera:Camera):Ray;
(* Get a ray trace from mouse position *)

PROCEDURE GetCameraMatrix(camera:Camera):Matrix;
(* Get camera transform matrix (view matrix) *)

PROCEDURE GetCameraMatrix2D(camera:Camera2D):Matrix;
(* Get camera 2d transform matrix *)

PROCEDURE GetWorldToScreen(position:Vector3; camera:Camera):Vector2;
(* Get the screen space position for a 3d world space position *)

PROCEDURE GetScreenToWorld2D(position:Vector2; camera:Camera2D):Vector2;
(* Get the world space position for a 2d camera screen space position *)

PROCEDURE GetWorldToScreenEx(position:Vector3; camera:Camera; width:Int; height:Int):Vector2;
(* Get size position for a 3d world space position *)

PROCEDURE GetWorldToScreen2D(position:Vector2; camera:Camera2D):Vector2;
(* Get the screen space position for a 2d camera world space position *)

(* Timing-related PROCEDUREs *)

PROCEDURE SetTargetFPS(fps:Int);
(* Set target FPS (maximum) *)

PROCEDURE GetFrameTime():Float;
(* Get time in seconds for last frame drawn (delta time) *)

PROCEDURE GetTime():Double;
(* Get elapsed time in seconds since InitWindow() *)

PROCEDURE GetFPS():Int;
(* Get current FPS *)

(* Custom frame control PROCEDUREs *)

(* NOTE: Those PROCEDUREs are intended for advance users that want full control over the frame processing *)

(* By default EndDrawing() does this job: draws everything + SwapScreenBuffer() + manage frame timing + PollInputEvents() *)

(* To avoid that behaviour and control frame processes manually, enable in config.h: SUPPORT_CUSTOM_FRAME_CONTROL *)

PROCEDURE SwapScreenBuffer;
(* Swap back buffer with front buffer (screen drawing) *)

PROCEDURE PollInputEvents;
(* Register all input events *)

PROCEDURE WaitTime(seconds:Double);
(* Wait for some time (halt program execution) *)

(* Random values generation PROCEDUREs *)

PROCEDURE SetRandomSeed(seed:Unsigned);
(* Set the seed for the random number generator *)

PROCEDURE GetRandomValue(min:Int; max:Int):Int;
(* Get a random value between min and max (both included) *)

PROCEDURE LoadRandomSequence(count:Unsigned; min:Int; max:Int):ADDRESS;
(* Load random values sequence, no values repeated *)

PROCEDURE UnloadRandomSequence(sequence:ADDRESS);
(* Unload random values sequence *)

(* Misc. PROCEDUREs *)

PROCEDURE TakeScreenshot(fileName:ARRAY OF CHAR);
(* Takes a screenshot of current screen (filename extension defines format) *)

PROCEDURE SetConfigFlags(flags:Unsigned);
(* Setup init configuration flags (view FLAGS) *)

PROCEDURE OpenURL(url:ARRAY OF CHAR);
(* Open URL with default system browser (if available) *)

(* NOTE: Following PROCEDUREs implemented in module [utils] *)

(*------------------------------------------------------------------ *)

PROCEDURE TraceLog(logLevel:Int; text:ARRAY OF CHAR; ...);
(* Show trace log messages (LOG_DEBUG, LOG_INFO, LOG_WARNING, LOG_ERROR...) *)

PROCEDURE SetTraceLogLevel(logLevel:Int);
(* Set the current threshold (minimum) log level *)

PROCEDURE MemAlloc(size:Unsigned):ADDRESS;
(* Internal memory allocator *)

PROCEDURE MemRealloc(ptr:ADDRESS; size:Unsigned):ADDRESS;
(* Internal memory reallocator *)

PROCEDURE MemFree(ptr:ADDRESS);
(* Internal memory free *)

(* Set custom callbacks *)

(* WARNING: Callbacks setup is intended for advance users *)

PROCEDURE SetTraceLogCallback(callback:ADDRESS);
(* Set custom trace log *)

PROCEDURE SetLoadFileDataCallback(callback:ADDRESS);
(* Set custom file binary data loader *)

PROCEDURE SetSaveFileDataCallback(callback:ADDRESS);
(* Set custom file binary data saver *)

PROCEDURE SetLoadFileTextCallback(callback:ADDRESS);
(* Set custom file text data loader *)

PROCEDURE SetSaveFileTextCallback(callback:ADDRESS);
(* Set custom file text data saver *)

(* Files management PROCEDUREs *)

PROCEDURE LoadFileData(fileName:ARRAY OF CHAR; VAR dataSize:Int):ADDRESS;
(* Load file data as byte array (read) *)

PROCEDURE UnloadFileData(data:ADDRESS);
(* Unload file data allocated by LoadFileData() *)

PROCEDURE SaveFileData(fileName:ARRAY OF CHAR; data:ADDRESS; dataSize:Int):BOOLEAN;
(* Save data to file from byte array (write), returns true on success *)

PROCEDURE ExportDataAsCode(data:ADDRESS; dataSize:Int; fileName:ARRAY OF CHAR):BOOLEAN;
(* Export data to code (.h), returns true on success *)

PROCEDURE LoadFileText(fileName:ARRAY OF CHAR):ADDRESS;
(* Load text data from file (read), returns a '\0' terminated string *)

PROCEDURE UnloadFileText(text:ARRAY OF CHAR);
(* Unload file text data allocated by LoadFileText() *)

PROCEDURE SaveFileText(fileName:ARRAY OF CHAR; text:ARRAY OF CHAR):BOOLEAN;
(* Save text data to file (write), string must be '\0' terminated, returns true on success *)

(*------------------------------------------------------------------ *)

(* File system PROCEDUREs *)

PROCEDURE FileExists(fileName:ARRAY OF CHAR):BOOLEAN;
(* Check if file exists *)

PROCEDURE DirectoryExists(dirPath:ARRAY OF CHAR):BOOLEAN;
(* Check if a directory path exists *)

PROCEDURE IsFileExtension(fileName:ARRAY OF CHAR; ext:ARRAY OF CHAR):BOOLEAN;
(* Check file extension (including point: .png, .wav) *)

PROCEDURE GetFileLength(fileName:ARRAY OF CHAR):Int;
(* Get file length in bytes (NOTE: GetFileSize() conflicts with windows.h) *)

PROCEDURE GetFileExtension(fileName:ARRAY OF CHAR):ADDRESS;
(* Get pointer to extension for a filename string (includes dot: '.png') *)

PROCEDURE GetFileName(filePath:ARRAY OF CHAR):ADDRESS;
(* Get pointer to filename for a path string *)

PROCEDURE GetFileNameWithoutExt(filePath:ARRAY OF CHAR):ADDRESS;
(* Get filename string without extension (uses static string) *)

PROCEDURE GetDirectoryPath(filePath:ARRAY OF CHAR):ADDRESS;
(* Get full path for a given fileName with path (uses static string) *)

PROCEDURE GetPrevDirectoryPath(dirPath:ARRAY OF CHAR):ADDRESS;
(* Get previous directory path for a given path (uses static string) *)

PROCEDURE GetWorkingDirectory():ADDRESS;
(* Get current working directory (uses static string) *)

PROCEDURE GetApplicationDirectory():ADDRESS;
(* Get the directory of the running application (uses static string) *)

PROCEDURE ChangeDirectory(dir:ARRAY OF CHAR):BOOLEAN;
(* Change working directory, return true on success *)

PROCEDURE IsPathFile(path:ARRAY OF CHAR):BOOLEAN;
(* Check if a given path is a file or a directory *)

PROCEDURE LoadDirectoryFiles(dirPath:ARRAY OF CHAR):FilePathList;
(* Load directory filepaths *)

PROCEDURE LoadDirectoryFilesEx(basePath:ARRAY OF CHAR; filter:ARRAY OF CHAR; scanSubdirs:BOOLEAN):FilePathList;
(* Load directory filepaths with extension filtering and recursive directory scan *)

PROCEDURE UnloadDirectoryFiles(files:FilePathList);
(* Unload filepaths *)

PROCEDURE IsFileDropped():BOOLEAN;
(* Check if a file has been dropped into window *)

PROCEDURE LoadDroppedFiles():FilePathList;
(* Load dropped filepaths *)

PROCEDURE UnloadDroppedFiles(files:FilePathList);
(* Unload dropped filepaths *)

PROCEDURE GetFileModTime(fileName:ARRAY OF CHAR):Long;
(* Get file modification time (last write time) *)

(* Compression/Encoding PROCEDUREality *)

PROCEDURE CompressData(data:ADDRESS; dataSize:Int; VAR compDataSize:Int):ADDRESS;
(* Compress data (DEFLATE algorithm), memory must be MemFree() *)

PROCEDURE DecompressData(compData:ADDRESS; compDataSize:Int; VAR dataSize:Int):ADDRESS;
(* Decompress data (DEFLATE algorithm), memory must be MemFree() *)

PROCEDURE EncodeDataBase64(data:ADDRESS; dataSize:Int; VAR outputSize:Int):ADDRESS;
(* Encode data to Base64 string, memory must be MemFree() *)

PROCEDURE DecodeDataBase64(data:ADDRESS; VAR outputSize:Int):ADDRESS;
(* Decode Base64 string data, memory must be MemFree() *)

(* Automation events PROCEDUREality *)

PROCEDURE LoadAutomationEventList(fileName:ARRAY OF CHAR):AutomationEventList;
(* Load automation events list from file, NULL for empty list, capacity = MAX_AUTOMATION_EVENTS *)

PROCEDURE UnloadAutomationEventList(list:AutomationEventList);
(* Unload automation events list from file *)

PROCEDURE ExportAutomationEventList(list:AutomationEventList; fileName:ARRAY OF CHAR):BOOLEAN;
(* Export automation events list as text file *)

PROCEDURE SetAutomationEventList(list:ADDRESS);
(* Set automation event list to record to *)

PROCEDURE SetAutomationEventBaseFrame(frame:Int);
(* Set automation event internal base frame to start recording *)

PROCEDURE StartAutomationEventRecording;
(* Start recording automation events (AutomationEventList must be set) *)

PROCEDURE StopAutomationEventRecording;
(* Stop recording automation events *)

PROCEDURE PlayAutomationEvent(event:AutomationEvent);
(* Play a recorded automation event *)

(*------------------------------------------------------------------------------------ *)

(* Input Handling PROCEDUREs (Module: core) *)

(*------------------------------------------------------------------------------------ *)

(* Input-related PROCEDUREs: keyboard *)

PROCEDURE IsKeyPressed(key:Int):BOOLEAN;
(* Check if a key has been pressed once *)

PROCEDURE IsKeyPressedRepeat(key:Int):BOOLEAN;
(* Check if a key has been pressed again (Only PLATFORM_DESKTOP) *)

PROCEDURE IsKeyDown(key:Int):BOOLEAN;
(* Check if a key is being pressed *)

PROCEDURE IsKeyReleased(key:Int):BOOLEAN;
(* Check if a key has been released once *)

PROCEDURE IsKeyUp(key:Int):BOOLEAN;
(* Check if a key is NOT being pressed *)

PROCEDURE GetKeyPressed():Int;
(* Get key pressed (keycode), call it multiple times for keys queued, returns 0 when the queue is empty *)

PROCEDURE GetCharPressed():Int;
(* Get char pressed (unicode), call it multiple times for chars queued, returns 0 when the queue is empty *)

PROCEDURE SetExitKey(key:Int);
(* Set a custom key to exit program (default is ESC) *)

(* Input-related PROCEDUREs: gamepads *)

PROCEDURE IsGamepadAvailable(gamepad:Int):BOOLEAN;
(* Check if a gamepad is available *)

PROCEDURE GetGamepadName(gamepad:Int):ADDRESS;
(* Get gamepad internal name id *)

PROCEDURE IsGamepadButtonPressed(gamepad:Int; button:Int):BOOLEAN;
(* Check if a gamepad button has been pressed once *)

PROCEDURE IsGamepadButtonDown(gamepad:Int; button:Int):BOOLEAN;
(* Check if a gamepad button is being pressed *)

PROCEDURE IsGamepadButtonReleased(gamepad:Int; button:Int):BOOLEAN;
(* Check if a gamepad button has been released once *)

PROCEDURE IsGamepadButtonUp(gamepad:Int; button:Int):BOOLEAN;
(* Check if a gamepad button is NOT being pressed *)

PROCEDURE GetGamepadButtonPressed():Int;
(* Get the last gamepad button pressed *)

PROCEDURE GetGamepadAxisCount(gamepad:Int):Int;
(* Get gamepad axis count for a gamepad *)

PROCEDURE GetGamepadAxisMovement(gamepad:Int; axis:Int):Float;
(* Get axis movement value for a gamepad axis *)

PROCEDURE SetGamepadMappings(mappings:ARRAY OF CHAR):Int;
(* Set internal gamepad mappings (SDL_GameControllerDB) *)

(* Input-related PROCEDUREs: mouse *)

PROCEDURE IsMouseButtonPressed(button:Int):BOOLEAN;
(* Check if a mouse button has been pressed once *)

PROCEDURE IsMouseButtonDown(button:Int):BOOLEAN;
(* Check if a mouse button is being pressed *)

PROCEDURE IsMouseButtonReleased(button:Int):BOOLEAN;
(* Check if a mouse button has been released once *)

PROCEDURE IsMouseButtonUp(button:Int):BOOLEAN;
(* Check if a mouse button is NOT being pressed *)

PROCEDURE GetMouseX():Int;
(* Get mouse position X *)

PROCEDURE GetMouseY():Int;
(* Get mouse position Y *)

PROCEDURE GetMousePosition():Vector2;
(* Get mouse position XY *)

PROCEDURE GetMouseDelta():Vector2;
(* Get mouse delta between frames *)

PROCEDURE SetMousePosition(x:Int; y:Int);
(* Set mouse position XY *)

PROCEDURE SetMouseOffset(offsetX:Int; offsetY:Int);
(* Set mouse offset *)

PROCEDURE SetMouseScale(scaleX:Float; scaleY:Float);
(* Set mouse scaling *)

PROCEDURE GetMouseWheelMove():Float;
(* Get mouse wheel movement for X or Y, whichever is larger *)

PROCEDURE GetMouseWheelMoveV():Vector2;
(* Get mouse wheel movement for both X and Y *)

PROCEDURE SetMouseCursor(cursor:Int);
(* Set mouse cursor *)

(* Input-related PROCEDUREs: touch *)

PROCEDURE GetTouchX():Int;
(* Get touch position X for touch point 0 (relative to screen size) *)

PROCEDURE GetTouchY():Int;
(* Get touch position Y for touch point 0 (relative to screen size) *)

PROCEDURE GetTouchPosition(index:Int):Vector2;
(* Get touch position XY for a touch point index (relative to screen size) *)

PROCEDURE GetTouchPointId(index:Int):Int;
(* Get touch point identifier for given index *)

PROCEDURE GetTouchPointCount():Int;
(* Get number of touch points *)

(*------------------------------------------------------------------------------------ *)

(* Gestures and Touch Handling PROCEDUREs (Module: rgestures) *)

(*------------------------------------------------------------------------------------ *)

PROCEDURE SetGesturesEnabled(flags:Unsigned);
(* Enable a set of gestures using flags *)

PROCEDURE IsGestureDetected(gesture:Unsigned):BOOLEAN;
(* Check if a gesture have been detected *)

PROCEDURE GetGestureDetected():Int;
(* Get latest detected gesture *)

PROCEDURE GetGestureHoldDuration():Float;
(* Get gesture hold time in milliseconds *)

PROCEDURE GetGestureDragVector():Vector2;
(* Get gesture drag vector *)

PROCEDURE GetGestureDragAngle():Float;
(* Get gesture drag angle *)

PROCEDURE GetGesturePinchVector():Vector2;
(* Get gesture pinch delta *)

PROCEDURE GetGesturePinchAngle():Float;
(* Get gesture pinch angle *)

(*------------------------------------------------------------------------------------ *)

(* Camera System PROCEDUREs (Module: rcamera) *)

(*------------------------------------------------------------------------------------ *)

PROCEDURE UpdateCamera(camera:ADDRESS; mode:Int);
(* Update camera position for selected mode *)

PROCEDURE UpdateCameraPro(camera:ADDRESS; movement:Vector3; rotation:Vector3; zoom:Float);
(* Update camera movement/rotation *)

(*------------------------------------------------------------------------------------ *)

(* Basic Shapes Drawing PROCEDUREs (Module: shapes) *)

(*------------------------------------------------------------------------------------ *)

(* Set texture and rectangle to be used on shapes drawing *)

(* NOTE: It can be useful when using basic shapes and one single font, *)

(* defining a font char white rectangle would allow drawing everything in a single draw call *)

PROCEDURE SetShapesTexture(texture:Texture2D; source:Rectangle);
(* Set texture and rectangle to be used on shapes drawing *)

PROCEDURE GetShapesTexture():Texture2D;
(* Get texture that is used for shapes drawing *)

PROCEDURE GetShapesTextureRectangle():Rectangle;
(* Get texture source rectangle that is used for shapes drawing *)

(* Basic shapes drawing PROCEDUREs *)

PROCEDURE DrawPixel(posX:Int; posY:Int; color:Color);
(* Draw a pixel *)

PROCEDURE DrawPixelV(position:Vector2; color:Color);
(* Draw a pixel (Vector version) *)

PROCEDURE DrawLine(startPosX:Int; startPosY:Int; endPosX:Int; endPosY:Int; color:Color);
(* Draw a line *)

PROCEDURE DrawLineV(startPos:Vector2; endPos:Vector2; color:Color);
(* Draw a line (using gl lines) *)

PROCEDURE DrawLineEx(startPos:Vector2; endPos:Vector2; thick:Float; color:Color);
(* Draw a line (using triangles/quads) *)

PROCEDURE DrawLineStrip(points:ARRAY OF Vector2; pointCount:Int; color:Color);
(* Draw lines sequence (using gl lines) *)

PROCEDURE DrawLineBezier(startPos:Vector2; endPos:Vector2; thick:Float; color:Color);
(* Draw line segment cubic-bezier in-out interpolation *)

PROCEDURE DrawCircle(centerX:Int; centerY:Int; radius:Float; color:Color);
(* Draw a color-filled circle *)

PROCEDURE DrawCircleSector(center:Vector2; radius:Float; startAngle:Float; endAngle:Float; segments:Int; color:Color);
(* Draw a piece of a circle *)

PROCEDURE DrawCircleSectorLines(center:Vector2; radius:Float; startAngle:Float; endAngle:Float; segments:Int; color:Color);
(* Draw circle sector outline *)

PROCEDURE DrawCircleGradient(centerX:Int; centerY:Int; radius:Float; color1:Color; color2:Color);
(* Draw a gradient-filled circle *)

PROCEDURE DrawCircleV(center:Vector2; radius:Float; color:Color);
(* Draw a color-filled circle (Vector version) *)

PROCEDURE DrawCircleLines(centerX:Int; centerY:Int; radius:Float; color:Color);
(* Draw circle outline *)

PROCEDURE DrawCircleLinesV(center:Vector2; radius:Float; color:Color);
(* Draw circle outline (Vector version) *)

PROCEDURE DrawEllipse(centerX:Int; centerY:Int; radiusH:Float; radiusV:Float; color:Color);
(* Draw ellipse *)

PROCEDURE DrawEllipseLines(centerX:Int; centerY:Int; radiusH:Float; radiusV:Float; color:Color);
(* Draw ellipse outline *)

PROCEDURE DrawRing(center:Vector2; innerRadius:Float; outerRadius:Float; startAngle:Float; endAngle:Float; segments:Int; color:Color);
(* Draw ring *)

PROCEDURE DrawRingLines(center:Vector2; innerRadius:Float; outerRadius:Float; startAngle:Float; endAngle:Float; segments:Int; color:Color);
(* Draw ring outline *)

PROCEDURE DrawRectangle(posX:Int; posY:Int; width:Int; height:Int; color:Color);
(* Draw a color-filled rectangle *)

PROCEDURE DrawRectangleV(position:Vector2; size:Vector2; color:Color);
(* Draw a color-filled rectangle (Vector version) *)

PROCEDURE DrawRectangleRec(rec:Rectangle; color:Color);
(* Draw a color-filled rectangle *)

PROCEDURE DrawRectanglePro(rec:Rectangle; origin:Vector2; rotation:Float; color:Color);
(* Draw a color-filled rectangle with pro parameters *)

PROCEDURE DrawRectangleGradientV(posX:Int; posY:Int; width:Int; height:Int; color1:Color;
            color2:Color);
(* Draw a vertical-gradient-filled rectangle *)

PROCEDURE DrawRectangleGradientH(posX:Int; posY:Int; width:Int; height:Int; color1:Color;
            color2:Color);
(* Draw a horizontal-gradient-filled rectangle *)

PROCEDURE DrawRectangleGradientEx(rec:Rectangle; col1:Color; col2:Color; col3:Color; col4:Color);
(* Draw a gradient-filled rectangle with custom vertex colors *)

PROCEDURE DrawRectangleLines(posX:Int; posY:Int; width:Int; height:Int; color:Color);
(* Draw rectangle outline *)

PROCEDURE DrawRectangleLinesEx(rec:Rectangle; lineThick:Float; color:Color);
(* Draw rectangle outline with extended parameters *)

PROCEDURE DrawRectangleRounded(rec:Rectangle; roundness:Float; segments:Int; color:Color);
(* Draw rectangle with rounded edges *)

PROCEDURE DrawRectangleRoundedLines(rec:Rectangle; roundness:Float; segments:Int; lineThick:Float; color:Color);
(* Draw rectangle with rounded edges outline *)

PROCEDURE DrawTriangle(v1:Vector2; v2:Vector2; v3:Vector2; color:Color);
(* Draw a color-filled triangle (vertex in counter-clockwise order!) *)

PROCEDURE DrawTriangleLines(v1:Vector2; v2:Vector2; v3:Vector2; color:Color);
(* Draw triangle outline (vertex in counter-clockwise order!) *)

PROCEDURE DrawTriangleFan(points:ARRAY OF Vector2; pointCount:Int; color:Color);
(* Draw a triangle fan defined by points (first vertex is the center) *)

PROCEDURE DrawTriangleStrip(points:ARRAY OF Vector2; pointCount:Int; color:Color);
(* Draw a triangle strip defined by points *)

PROCEDURE DrawPoly(center:Vector2; sides:Int; radius:Float; rotation:Float; color:Color);
(* Draw a regular polygon (Vector version) *)

PROCEDURE DrawPolyLines(center:Vector2; sides:Int; radius:Float; rotation:Float; color:Color);
(* Draw a polygon outline of n sides *)

PROCEDURE DrawPolyLinesEx(center:Vector2; sides:Int; radius:Float; rotation:Float; lineThick:Float; color:Color);
(* Draw a polygon outline of n sides with extended parameters *)

(* Splines drawing PROCEDUREs *)

PROCEDURE DrawSplineLinear(points:ARRAY OF Vector2; pointCount:Int; thick:Float; color:Color);
(* Draw spline: Linear, minimum 2 points *)

PROCEDURE DrawSplineBasis(points:ARRAY OF Vector2; pointCount:Int; thick:Float; color:Color);
(* Draw spline: B-Spline, minimum 4 points *)

PROCEDURE DrawSplineCatmullRom(points:ARRAY OF Vector2; pointCount:Int; thick:Float; color:Color);
(* Draw spline: Catmull-Rom, minimum 4 points *)

PROCEDURE DrawSplineBezierQuadratic(points:ARRAY OF Vector2; pointCount:Int; thick:Float; color:Color);
(* Draw spline: Quadratic Bezier, minimum 3 points (1 control point): [p1, c2, p3, c4...] *)

PROCEDURE DrawSplineBezierCubic(points:ARRAY OF Vector2; pointCount:Int; thick:Float; color:Color);
(* Draw spline: Cubic Bezier, minimum 4 points (2 control points): [p1, c2, c3, p4, c5, c6...] *)

PROCEDURE DrawSplineSegmentLinear(p1:Vector2; p2:Vector2; thick:Float; color:Color);
(* Draw spline segment: Linear, 2 points *)

PROCEDURE DrawSplineSegmentBasis(p1:Vector2; p2:Vector2; p3:Vector2; p4:Vector2; thick:Float;
            color:Color);
(* Draw spline segment: B-Spline, 4 points *)

PROCEDURE DrawSplineSegmentCatmullRom(p1:Vector2; p2:Vector2; p3:Vector2; p4:Vector2; thick:Float;
            color:Color);
(* Draw spline segment: Catmull-Rom, 4 points *)

PROCEDURE DrawSplineSegmentBezierQuadratic(p1:Vector2; c2:Vector2; p3:Vector2; thick:Float; color:Color);
(* Draw spline segment: Quadratic Bezier, 2 points, 1 control point *)

PROCEDURE DrawSplineSegmentBezierCubic(p1:Vector2; c2:Vector2; c3:Vector2; p4:Vector2; thick:Float;
            color:Color);
(* Draw spline segment: Cubic Bezier, 2 points, 2 control points *)

(* Spline segment point evaluation PROCEDUREs, for a given t [0.0f .. 1.0f] *)

PROCEDURE GetSplinePointLinear(startPos:Vector2; endPos:Vector2; t:Float):Vector2;
(* Get (evaluate) spline point: Linear *)

PROCEDURE GetSplinePointBasis(p1:Vector2; p2:Vector2; p3:Vector2; p4:Vector2; t:Float):Vector2;
(* Get (evaluate) spline point: B-Spline *)

PROCEDURE GetSplinePointCatmullRom(p1:Vector2; p2:Vector2; p3:Vector2; p4:Vector2; t:Float):Vector2;
(* Get (evaluate) spline point: Catmull-Rom *)

PROCEDURE GetSplinePointBezierQuad(p1:Vector2; c2:Vector2; p3:Vector2; t:Float):Vector2;
(* Get (evaluate) spline point: Quadratic Bezier *)

PROCEDURE GetSplinePointBezierCubic(p1:Vector2; c2:Vector2; c3:Vector2; p4:Vector2; t:Float):Vector2;
(* Get (evaluate) spline point: Cubic Bezier *)

(* Basic shapes collision detection PROCEDUREs *)

PROCEDURE CheckCollisionRecs(rec1:Rectangle; rec2:Rectangle):BOOLEAN;
(* Check collision between two rectangles *)

PROCEDURE CheckCollisionCircles(center1:Vector2; radius1:Float; center2:Vector2; radius2:Float):BOOLEAN;
(* Check collision between two circles *)

PROCEDURE CheckCollisionCircleRec(center:Vector2; radius:Float; rec:Rectangle):BOOLEAN;
(* Check collision between circle and rectangle *)

PROCEDURE CheckCollisionPointRec(point:Vector2; rec:Rectangle):BOOLEAN;
(* Check if point is inside rectangle *)

PROCEDURE CheckCollisionPointCircle(point:Vector2; center:Vector2; radius:Float):BOOLEAN;
(* Check if point is inside circle *)

PROCEDURE CheckCollisionPointTriangle(point:Vector2; p1:Vector2; p2:Vector2; p3:Vector2):BOOLEAN;
(* Check if point is inside a triangle *)

PROCEDURE CheckCollisionPointPoly(point:Vector2; points:ARRAY OF Vector2; pointCount:Int):BOOLEAN;
(* Check if point is within a polygon described by array of vertices *)

PROCEDURE CheckCollisionLines(startPos1:Vector2; endPos1:Vector2; startPos2:Vector2; endPos2:Vector2; collisionPoint:ARRAY OF Vector2):BOOLEAN;
(* Check the collision between two lines defined by two points each, returns collision point by reference *)

PROCEDURE CheckCollisionPointLine(point:Vector2; p1:Vector2; p2:Vector2; threshold:Int):BOOLEAN;
(* Check if point belongs to line created between two points [p1] and [p2] with defined margin in pixels [threshold] *)

PROCEDURE GetCollisionRec(rec1:Rectangle; rec2:Rectangle):Rectangle;
(* Get collision rectangle for two rectangles collision *)

(*------------------------------------------------------------------------------------ *)

(* Texture Loading and Drawing PROCEDUREs (Module: textures) *)

(*------------------------------------------------------------------------------------ *)

(* Image loading PROCEDUREs *)

(* NOTE: These PROCEDUREs do not require GPU access *)

PROCEDURE LoadImage(fileName:ARRAY OF CHAR):Image;
(* Load image from file into CPU memory (RAM) *)

PROCEDURE LoadImageRaw(fileName:ARRAY OF CHAR; width:Int; height:Int; format:Int; headerSize:Int):Image;
(* Load image from RAW file data *)

PROCEDURE LoadImageSvg(fileNameOrString:ARRAY OF CHAR; width:Int; height:Int):Image;
(* Load image from SVG file data or string with specified size *)

PROCEDURE LoadImageAnim(fileName:ARRAY OF CHAR; VAR frames:Int):Image;
(* Load image sequence from file (frames appended to image.data) *)

PROCEDURE LoadImageAnimFromMemory(fileType:ARRAY OF CHAR; fileData:ADDRESS; dataSize:Int; VAR frames:Int):Image;
(* Load image sequence from memory buffer *)

PROCEDURE LoadImageFromMemory(fileType:ARRAY OF CHAR; fileData:ADDRESS; dataSize:Int):Image;
(* Load image from memory buffer, fileType refers to extension: i.e. '.png' *)

PROCEDURE LoadImageFromTexture(texture:Texture2D):Image;
(* Load image from GPU texture data *)

PROCEDURE LoadImageFromScreen():Image;
(* Load image from screen buffer and (screenshot) *)

PROCEDURE IsImageReady(image:Image):BOOLEAN;
(* Check if an image is ready *)

PROCEDURE UnloadImage(image:Image);
(* Unload image from CPU memory (RAM) *)

PROCEDURE ExportImage(image:Image; fileName:ARRAY OF CHAR):BOOLEAN;
(* Export image data to file, returns true on success *)

PROCEDURE ExportImageToMemory(image:Image; fileType:ARRAY OF CHAR; VAR fileSize:Int):ADDRESS;
(* Export image to memory buffer *)

PROCEDURE ExportImageAsCode(image:Image; fileName:ARRAY OF CHAR):BOOLEAN;
(* Export image as code file defining an array of bytes, returns true on success *)

(* Image generation PROCEDUREs *)

PROCEDURE GenImageColor(width:Int; height:Int; color:Color):Image;
(* Generate image: plain color *)

PROCEDURE GenImageGradientLinear(width:Int; height:Int; direction:Int; start:Color; end:Color):Image;
(* Generate image: linear gradient, direction in degrees [0..360], 0=Vertical gradient *)

PROCEDURE GenImageGradientRadial(width:Int; height:Int; density:Float; inner:Color; outer:Color):Image;
(* Generate image: radial gradient *)

PROCEDURE GenImageGradientSquare(width:Int; height:Int; density:Float; inner:Color; outer:Color):Image;
(* Generate image: square gradient *)

PROCEDURE GenImageChecked(width:Int; height:Int; checksX:Int; checksY:Int; col1:Color;
           col2:Color):Image;
(* Generate image: checked *)

PROCEDURE GenImageWhiteNoise(width:Int; height:Int; factor:Float):Image;
(* Generate image: white noise *)

PROCEDURE GenImagePerlinNoise(width:Int; height:Int; offsetX:Int; offsetY:Int; scale:Float):Image;
(* Generate image: perlin noise *)

PROCEDURE GenImageCellular(width:Int; height:Int; tileSize:Int):Image;
(* Generate image: cellular algorithm, bigger tileSize means bigger cells *)

PROCEDURE GenImageText(width:Int; height:Int; text:ARRAY OF CHAR):Image;
(* Generate image: grayscale image from text data *)

(* Image manipulation PROCEDUREs *)

PROCEDURE ImageCopy(image:Image):Image;
(* Create an image duplicate (useful for transformations) *)

PROCEDURE ImageFromImage(image:Image; rec:Rectangle):Image;
(* Create an image from another image piece *)

PROCEDURE ImageText(text:ARRAY OF CHAR; fontSize:Int; color:Color):Image;
(* Create an image from text (default font) *)

PROCEDURE ImageTextEx(font:Font; text:ARRAY OF CHAR; fontSize:Float; spacing:Float; tint:Color):Image;
(* Create an image from text (custom sprite font) *)

PROCEDURE ImageFormat(VAR image:Image; newFormat:Int);
(* Convert image data to desired format *)

PROCEDURE ImageToPOT(VAR image : Image; fill:Color);
(* Convert image to POT (power-of-two) *)

PROCEDURE ImageCrop(VAR image : Image; crop:Rectangle);
(* Crop an image to a defined rectangle *)

PROCEDURE ImageAlphaCrop(VAR image : Image; threshold:Float);
(* Crop image depending on alpha value *)

PROCEDURE ImageAlphaClear(VAR image : Image; color:Color; threshold:Float);
(* Clear alpha channel to desired color *)

PROCEDURE ImageAlphaMask(VAR image : Image; alphaMask:Image);
(* Apply alpha mask to image *)

PROCEDURE ImageAlphaPremultiply(VAR image : Image);
(* Premultiply alpha channel *)

PROCEDURE ImageBlurGaussian(VAR image : Image; blurSize:Int);
(* Apply Gaussian blur using a box blur approximation *)

PROCEDURE ImageKernelConvolution(VAR image:Image; kernel: ARRAY OF Float; kernelSize:Int);
(* Apply Custom Square image convolution kernel *)

PROCEDURE ImageResize(VAR image:Image; newWidth:Int; newHeight:Int);
(* Resize image (Bicubic scaling algorithm) *)

PROCEDURE ImageResizeNN(VAR image:Image; newWidth:Int; newHeight:Int);
(* Resize image (Nearest-Neighbor scaling algorithm) *)

PROCEDURE ImageResizeCanvas(VAR image:Image; newWidth:Int; newHeight:Int; offsetX:Int; offsetY:Int;
            fill:Color);
(* Resize canvas and fill with color *)

PROCEDURE ImageMipmaps(VAR image:Image);
(* Compute all mipmap levels for a provided image *)

PROCEDURE ImageDither(VAR image:Image; rBpp:Int; gBpp:Int; bBpp:Int; aBpp:Int);
(* Dither image data to 16bpp or lower (Floyd-Steinberg dithering) *)

PROCEDURE ImageFlipVertical(VAR image:Image);
(* Flip image vertically *)

PROCEDURE ImageFlipHorizontal(VAR image:Image);
(* Flip image horizontally *)

PROCEDURE ImageRotate(VAR image:Image; degrees:Int);
(* Rotate image by input angle in degrees (-359 to 359) *)

PROCEDURE ImageRotateCW(VAR image:Image);
(* Rotate image clockwise 90deg *)

PROCEDURE ImageRotateCCW(VAR image:Image);
(* Rotate image counter-clockwise 90deg *)

PROCEDURE ImageColorTint(VAR image:Image; color:Color);
(* Modify image color: tint *)

PROCEDURE ImageColorInvert(VAR image:Image);
(* Modify image color: invert *)

PROCEDURE ImageColorGrayscale(VAR image:Image);
(* Modify image color: grayscale *)

PROCEDURE ImageColorContrast(VAR image:Image; contrast:Float);
(* Modify image color: contrast (-100 to 100) *)

PROCEDURE ImageColorBrightness(VAR image:Image; brightness:Int);
(* Modify image color: brightness (-255 to 255) *)

PROCEDURE ImageColorReplace(VAR image:Image; color:Color; replace:Color);
(* Modify image color: replace color *)

PROCEDURE LoadImageColors(image:Image):ADDRESS;
(* Load color data from image as a Color array (RGBA - 32bit) *)

PROCEDURE LoadImagePalette(image:Image; maxPaletteSize:Int; VAR colorCount:Int):ADDRESS;
(* Load colors palette from image as a Color array (RGBA - 32bit) *)

PROCEDURE UnloadImageColors(colors:ARRAY OF Color);
(* Unload color data loaded with LoadImageColors() *)

PROCEDURE UnloadImagePalette(colors:ARRAY OF Color);
(* Unload colors palette loaded with LoadImagePalette() *)

PROCEDURE GetImageAlphaBorder(image:Image; threshold:Float):Rectangle;
(* Get image alpha border rectangle *)

PROCEDURE GetImageColor(image:Image; x:Int; y:Int):Color;
(* Get image pixel color at (x, y) position *)

(* Image drawing PROCEDUREs *)

(* NOTE: Image software-rendering PROCEDUREs (CPU) *)

PROCEDURE ImageClearBackground(VAR dst:Image; color:Color);
(* Clear image background with given color *)

PROCEDURE ImageDrawPixel(VAR dst : Image; posX:Int; posY:Int; color:Color);
(* Draw pixel within an image *)

PROCEDURE ImageDrawPixelV(VAR dst : Image; position:Vector2; color:Color);
(* Draw pixel within an image (Vector version) *)

PROCEDURE ImageDrawLine(VAR dst : Image; startPosX:Int; startPosY:Int; endPosX:Int; endPosY:Int; color:Color);
(* Draw line within an image *)

PROCEDURE ImageDrawLineV(VAR dst : Image; start:Vector2; end:Vector2; color:Color);
(* Draw line within an image (Vector version) *)

PROCEDURE ImageDrawCircle(VAR dst : Image; centerX:Int; centerY:Int; radius:Int; color:Color);
(* Draw a filled circle within an image *)

PROCEDURE ImageDrawCircleV(VAR dst : Image; center:Vector2; radius:Int; color:Color);
(* Draw a filled circle within an image (Vector version) *)

PROCEDURE ImageDrawCircleLines(VAR dst : Image; centerX:Int; centerY:Int; radius:Int; color:Color);
(* Draw circle outline within an image *)

PROCEDURE ImageDrawCircleLinesV(VAR dst : Image; center:Vector2; radius:Int; color:Color);
(* Draw circle outline within an image (Vector version) *)

PROCEDURE ImageDrawRectangle(VAR dst : Image; posX:Int; posY:Int; width:Int; height:Int;
            color:Color);
(* Draw rectangle within an image *)

PROCEDURE ImageDrawRectangleV(VAR dst : Image; position:Vector2; size:Vector2; color:Color);
(* Draw rectangle within an image (Vector version) *)

PROCEDURE ImageDrawRectangleRec(VAR dst : Image; rec:Rectangle; color:Color);
(* Draw rectangle within an image *)

PROCEDURE ImageDrawRectangleLines(VAR dst : Image; rec:Rectangle; thick:Int; color:Color);
(* Draw rectangle lines within an image *)

PROCEDURE ImageDraw(VAR dst : Image; src:Image; srcRec:Rectangle; dstRec:Rectangle; tint:Color);
(* Draw a source image within a destination image (tint applied to source) *)

PROCEDURE ImageDrawText(VAR dst : Image; text:ARRAY OF CHAR; posX:Int; posY:Int; fontSize:Int;
            color:Color);
(* Draw text (using default font) within an image (destination) *)

PROCEDURE ImageDrawTextEx(VAR dst : Image; font:Font; text:ARRAY OF CHAR; position:Vector2; fontSize:Float;
            spacing:Float; tint:Color);
(* Draw text (custom sprite font) within an image (destination) *)

(* Texture loading PROCEDUREs *)

(* NOTE: These PROCEDUREs require GPU access *)

PROCEDURE LoadTexture(fileName:ARRAY OF CHAR):Texture2D;
(* Load texture from file into GPU memory (VRAM) *)

PROCEDURE LoadTextureFromImage(image:Image):Texture2D;
(* Load texture from image data *)

PROCEDURE LoadTextureCubemap(image:Image; layout:Int):TextureCubemap;
(* Load cubemap from image, multiple image cubemap layouts supported *)

PROCEDURE LoadRenderTexture(width:Int; height:Int):RenderTexture2D;
(* Load texture for rendering (framebuffer) *)

PROCEDURE IsTextureReady(texture:Texture2D):BOOLEAN;
(* Check if a texture is ready *)

PROCEDURE UnloadTexture(texture:Texture2D);
(* Unload texture from GPU memory (VRAM) *)

PROCEDURE IsRenderTextureReady(target:RenderTexture2D):BOOLEAN;
(* Check if a render texture is ready *)

PROCEDURE UnloadRenderTexture(target:RenderTexture2D);
(* Unload render texture from GPU memory (VRAM) *)

PROCEDURE UpdateTexture(texture:Texture2D; pixels:ADDRESS);
(* Update GPU texture with new data *)

PROCEDURE UpdateTextureRec(texture:Texture2D; rec:Rectangle; pixels:ADDRESS);
(* Update GPU texture rectangle with new data *)

(* Texture configuration PROCEDUREs *)

PROCEDURE GenTextureMipmaps(VAR texture:Texture2D);
(* Generate GPU mipmaps for a texture *)

PROCEDURE SetTextureFilter(texture:Texture2D; filter:Int);
(* Set texture scaling filter mode *)

PROCEDURE SetTextureWrap(texture:Texture2D; wrap:Int);
(* Set texture wrapping mode *)

(* Texture drawing PROCEDUREs *)

PROCEDURE DrawTexture(texture:Texture2D; posX:Int; posY:Int; tint:Color);
(* Draw a Texture2D *)

PROCEDURE DrawTextureV(texture:Texture2D; position:Vector2; tint:Color);
(* Draw a Texture2D with position defined as Vector2 *)

PROCEDURE DrawTextureEx(texture:Texture2D; position:Vector2; rotation:Float; scale:Float; tint:Color);
(* Draw a Texture2D with extended parameters *)

PROCEDURE DrawTextureRec(texture:Texture2D; source:Rectangle; position:Vector2; tint:Color);
(* Draw a part of a texture defined by a rectangle *)

PROCEDURE DrawTexturePro(texture:Texture2D; source:Rectangle; dest:Rectangle; origin:Vector2; rotation:Float;
            tint:Color);
(* Draw a part of a texture defined by a rectangle with 'pro' parameters *)

PROCEDURE DrawTextureNPatch(texture:Texture2D; nPatchInfo:NPatchInfo; dest:Rectangle; origin:Vector2; rotation:Float;
            tint:Color);
(* Draws a texture (or part of it) that stretches or shrinks nicely *)

(* Color/pixel related PROCEDUREs *)

PROCEDURE Fade(color:Color; alpha:Float):Color;
(* Get color with alpha applied, alpha goes from 0.0f to 1.0f *)

PROCEDURE ColorToInt(color:Color):Int;
(* Get hexadecimal value for a Color *)

PROCEDURE ColorNormalize(color:Color):Vector4;
(* Get Color normalized as float [0..1] *)

PROCEDURE ColorFromNormalized(normalized:Vector4):Color;
(* Get Color from normalized values [0..1] *)

PROCEDURE ColorToHSV(color:Color):Vector3;
(* Get HSV values for a Color, hue [0..360], saturation/value [0..1] *)

PROCEDURE ColorFromHSV(hue:Float; saturation:Float; value:Float):Color;
(* Get a Color from HSV values, hue [0..360], saturation/value [0..1] *)

PROCEDURE ColorTint(color:Color; tint:Color):Color;
(* Get color multiplied with another color *)

PROCEDURE ColorBrightness(color:Color; factor:Float):Color;
(* Get color with brightness correction, brightness factor goes from -1.0f to 1.0f *)

PROCEDURE ColorContrast(color:Color; contrast:Float):Color;
(* Get color with contrast correction, contrast values between -1.0f and 1.0f *)

PROCEDURE ColorAlpha(color:Color; alpha:Float):Color;
(* Get color with alpha applied, alpha goes from 0.0f to 1.0f *)

PROCEDURE ColorAlphaBlend(dst:Color; src:Color; tint:Color):Color;
(* Get src alpha-blended into dst color with tint *)

PROCEDURE GetColor(hexValue:Unsigned):Color;
(* Get Color structure from hexadecimal value *)

PROCEDURE GetPixelColor(srcPtr:ADDRESS; format:Int):Color;
(* Get Color from a source pixel pointer of certain format *)

PROCEDURE SetPixelColor(dstPtr:ADDRESS; color:Color; format:Int);
(* Set color formatted into destination pixel pointer *)

PROCEDURE GetPixelDataSize(width:Int; height:Int; format:Int):Int;
(* Get pixel data size in bytes for certain format *)

(*------------------------------------------------------------------------------------ *)

(* Font Loading and Text Drawing PROCEDUREs (Module: text) *)

(*------------------------------------------------------------------------------------ *)

(* Font loading/unloading PROCEDUREs *)

PROCEDURE GetFontDefault():Font;
(* Get the default Font *)

PROCEDURE LoadFont(fileName:ARRAY OF CHAR):Font;
(* Load font from file into GPU memory (VRAM) *)

PROCEDURE LoadFontEx(fileName:ARRAY OF CHAR; fontSize:Int; VAR codepoints:Int; codepointCount:Int):Font;
(* Load font from file with extended parameters, use NULL for codepoints and 0 for codepointCount to load the default character set *)

PROCEDURE LoadFontFromImage(image:Image; key:Color; firstChar:Int):Font;
(* Load font from Image (XNA style) *)

PROCEDURE LoadFontFromMemory(fileType:ARRAY OF CHAR; fileData:ADDRESS; dataSize:Int; fontSize:Int; VAR codepoints:Int; codepointCount:Int):Font;
(* Load font from memory buffer, fileType refers to extension: i.e. '.ttf' *)

PROCEDURE IsFontReady(font:Font):BOOLEAN;
(* Check if a font is ready *)

PROCEDURE LoadFontData(fileData:ADDRESS; dataSize:Int; fontSize:Int; VAR codepoints:Int; codepointCount:Int; _type:Int):ADDRESS;
(* Load font data for further use *)

PROCEDURE GenImageFontAtlas(glyphs:ARRAY OF GlyphInfo; glyphRecs:ARRAY OF ARRAY OF ADDRESS; glyphCount:Int; fontSize:Int; padding:Int;
           packMethod:Int):Image;
(* Generate image font atlas using chars info *)

PROCEDURE UnloadFontData(glyphs:ARRAY OF GlyphInfo; glyphCount:Int);
(* Unload font chars info data (RAM) *)

PROCEDURE UnloadFont(font:Font);
(* Unload font from GPU memory (VRAM) *)

PROCEDURE ExportFontAsCode(font:Font; fileName:ARRAY OF CHAR):BOOLEAN;
(* Export font as code file, returns true on success *)

(* Text drawing PROCEDUREs *)

PROCEDURE DrawFPS(posX:Int; posY:Int);
(* Draw current FPS *)

PROCEDURE DrawText(text:ARRAY OF CHAR; posX:Int; posY:Int; fontSize:Int; color:Color);
(* Draw text (using default font) *)

PROCEDURE DrawTextEx(font:Font; text:ARRAY OF CHAR; position:Vector2; fontSize:Float; spacing:Float;
            tint:Color);
(* Draw text using font and additional parameters *)

PROCEDURE DrawTextPro(font:Font; text:ARRAY OF CHAR; position:Vector2; origin:Vector2; rotation:Float;
            fontSize:Float; spacing:Float; tint:Color);
(* Draw text using Font and pro parameters (rotation) *)

PROCEDURE DrawTextCodepoint(font:Font; codepoint:Int; position:Vector2; fontSize:Float; tint:Color);
(* Draw one character (codepoint) *)

PROCEDURE DrawTextCodepoints(font:Font; VAR codepoints:Int; codepointCount:Int; position:Vector2; fontSize:Float;
            spacing:Float; tint:Color);
(* Draw multiple character (codepoint) *)

(* Text font info PROCEDUREs *)

PROCEDURE SetTextLineSpacing(spacing:Int);
(* Set vertical line spacing when drawing with line-breaks *)

PROCEDURE MeasureText(text:ARRAY OF CHAR; fontSize:Int):Int;
(* Measure string width for default font *)

PROCEDURE MeasureTextEx(font:Font; text:ARRAY OF CHAR; fontSize:Float; spacing:Float):Vector2;
(* Measure string size for Font *)

PROCEDURE GetGlyphIndex(font:Font; codepoint:Int):Int;
(* Get glyph index position in font for a codepoint (unicode character), fallback to '?' if not found *)

PROCEDURE GetGlyphInfo(font:Font; codepoint:Int):GlyphInfo;
(* Get glyph font info data for a codepoint (unicode character), fallback to '?' if not found *)

PROCEDURE GetGlyphAtlasRec(font:Font; codepoint:Int):Rectangle;
(* Get glyph rectangle in font atlas for a codepoint (unicode character), fallback to '?' if not found *)

(* Text codepoints management PROCEDUREs (unicode characters) *)

PROCEDURE LoadUTF8(codepoints:ARRAY OF Int; length:Int):ADDRESS;
(* Load UTF-8 text encoded from codepoints array *)

PROCEDURE UnloadUTF8(text:ARRAY OF CHAR);
(* Unload UTF-8 text encoded from codepoints array *)

PROCEDURE LoadCodepoints(text:ARRAY OF CHAR; VAR count:Int):ADDRESS;
(* Load all codepoints from a UTF-8 text string, codepoints count returned by parameter *)

PROCEDURE UnloadCodepoints(codepoints:ARRAY OF Int);
(* Unload codepoints data from memory *)

PROCEDURE GetCodepointCount(text:ARRAY OF CHAR):Int;
(* Get total number of codepoints in a UTF-8 encoded string *)

PROCEDURE GetCodepoint(text:ARRAY OF CHAR; VAR codepointSize:Int):Int;
(* Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure *)

PROCEDURE GetCodepointNext(text:ARRAY OF CHAR; VAR codepointSize:Int):Int;
(* Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure *)

PROCEDURE GetCodepointPrevious(text:ARRAY OF CHAR; VAR codepointSize:Int):Int;
(* Get previous codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure *)

PROCEDURE CodepointToUTF8(codepoint:Int; VAR utf8Size:Int):ADDRESS;
(* Encode one codepoint into UTF-8 byte array (array length returned as parameter) *)

(* Text strings management PROCEDUREs (no UTF-8 strings, only byte chars) *)

(* NOTE: Some strings allocate memory internally for returned strings, just be careful! *)

PROCEDURE TextCopy(dst:ARRAY OF CHAR; src:ARRAY OF CHAR):Int;
(* Copy one string to another, returns bytes copied *)

PROCEDURE TextIsEqual(text1:ARRAY OF CHAR; text2:ARRAY OF CHAR):BOOLEAN;
(* Check if two text string are equal *)

PROCEDURE TextLength(text:ARRAY OF CHAR):Unsigned;
(* Get text length, checks for '\0' ending *)

PROCEDURE TextFormat(text:ARRAY OF CHAR; ...):ADDRESS;
(* Text formatting with variables (sprintf() style) *)

PROCEDURE TextSubtext(text:ARRAY OF CHAR; position:Int; length:Int):ADDRESS;
(* Get a piece of a text string *)

PROCEDURE TextReplace(text:ARRAY OF CHAR; replace:ARRAY OF CHAR; by:ARRAY OF CHAR):ADDRESS;
(* Replace text string (WARNING: memory must be freed!) *)

PROCEDURE TextInsert(text:ARRAY OF CHAR; insert:ARRAY OF CHAR; position:Int):ADDRESS;
(* Insert text in a position (WARNING: memory must be freed!) *)

PROCEDURE TextJoin(textList:ARRAY OF ARRAY OF CHAR; count:Int; delimiter:ARRAY OF CHAR):ADDRESS;
(* Join text strings with delimiter *)

PROCEDURE TextSplit(text:ARRAY OF CHAR; delimiter:CHAR; VAR count:Int):ADDRESS;
(* Split text into multiple strings *)

PROCEDURE TextAppend(text:ARRAY OF CHAR; append:ARRAY OF CHAR; VAR position:Int);
(* Append text at specific position and move cursor! *)

PROCEDURE TextFindIndex(text:ARRAY OF CHAR; find:ARRAY OF CHAR):Int;
(* Find first text occurrence within a string *)

PROCEDURE TextToUpper(text:ARRAY OF CHAR):ADDRESS;
(* Get upper case version of provided string *)

PROCEDURE TextToLower(text:ARRAY OF CHAR):ADDRESS;
(* Get lower case version of provided string *)

PROCEDURE TextToPascal(text:ARRAY OF CHAR):ADDRESS;
(* Get Pascal case notation version of provided string *)

PROCEDURE TextToInteger(text:ARRAY OF CHAR):Int;
(* Get integer value from text (negative values not supported) *)

PROCEDURE TextToFloat(text:ARRAY OF CHAR):Float;
(* Get float value from text (negative values not supported) *)

(*------------------------------------------------------------------------------------ *)

(* Basic 3d Shapes Drawing PROCEDUREs (Module: models) *)

(*------------------------------------------------------------------------------------ *)

(* Basic geometric 3D shapes drawing PROCEDUREs *)

PROCEDURE DrawLine3D(startPos:Vector3; endPos:Vector3; color:Color);
(* Draw a line in 3D world space *)

PROCEDURE DrawPoint3D(position:Vector3; color:Color);
(* Draw a point in 3D space, actually a small line *)

PROCEDURE DrawCircle3D(center:Vector3; radius:Float; rotationAxis:Vector3; rotationAngle:Float; color:Color);
(* Draw a circle in 3D world space *)

PROCEDURE DrawTriangle3D(v1:Vector3; v2:Vector3; v3:Vector3; color:Color);
(* Draw a color-filled triangle (vertex in counter-clockwise order!) *)

PROCEDURE DrawTriangleStrip3D(points:ARRAY OF Vector3; pointCount:Int; color:Color);
(* Draw a triangle strip defined by points *)

PROCEDURE DrawCube(position:Vector3; width:Float; height:Float; length:Float; color:Color);
(* Draw cube *)

PROCEDURE DrawCubeV(position:Vector3; size:Vector3; color:Color);
(* Draw cube (Vector version) *)

PROCEDURE DrawCubeWires(position:Vector3; width:Float; height:Float; length:Float; color:Color);
(* Draw cube wires *)

PROCEDURE DrawCubeWiresV(position:Vector3; size:Vector3; color:Color);
(* Draw cube wires (Vector version) *)

PROCEDURE DrawSphere(centerPos:Vector3; radius:Float; color:Color);
(* Draw sphere *)

PROCEDURE DrawSphereEx(centerPos:Vector3; radius:Float; rings:Int; slices:Int; color:Color);
(* Draw sphere with extended parameters *)

PROCEDURE DrawSphereWires(centerPos:Vector3; radius:Float; rings:Int; slices:Int; color:Color);
(* Draw sphere wires *)

PROCEDURE DrawCylinder(position:Vector3; radiusTop:Float; radiusBottom:Float; height:Float; slices:Int;
            color:Color);
(* Draw a cylinder/cone *)

PROCEDURE DrawCylinderEx(startPos:Vector3; endPos:Vector3; startRadius:Float; endRadius:Float; sides:Int;
            color:Color);
(* Draw a cylinder with base at startPos and top at endPos *)

PROCEDURE DrawCylinderWires(position:Vector3; radiusTop:Float; radiusBottom:Float; height:Float; slices:Int;
            color:Color);
(* Draw a cylinder/cone wires *)

PROCEDURE DrawCylinderWiresEx(startPos:Vector3; endPos:Vector3; startRadius:Float; endRadius:Float; sides:Int;
            color:Color);
(* Draw a cylinder wires with base at startPos and top at endPos *)

PROCEDURE DrawCapsule(startPos:Vector3; endPos:Vector3; radius:Float; slices:Int; rings:Int;
            color:Color);
(* Draw a capsule with the center of its sphere caps at startPos and endPos *)

PROCEDURE DrawCapsuleWires(startPos:Vector3; endPos:Vector3; radius:Float; slices:Int; rings:Int;
            color:Color);
(* Draw capsule wireframe with the center of its sphere caps at startPos and endPos *)

PROCEDURE DrawPlane(centerPos:Vector3; size:Vector2; color:Color);
(* Draw a plane XZ *)

PROCEDURE DrawRay(ray:Ray; color:Color);
(* Draw a ray line *)

PROCEDURE DrawGrid(slices:Int; spacing:Float);
(* Draw a grid (centered at (0, 0, 0)) *)

(*------------------------------------------------------------------------------------ *)

(* Model 3d Loading and Drawing PROCEDUREs (Module: models) *)

(*------------------------------------------------------------------------------------ *)

(* Model management PROCEDUREs *)

PROCEDURE LoadModel(fileName:ARRAY OF CHAR):Model;
(* Load model from files (meshes and materials) *)

PROCEDURE LoadModelFromMesh(mesh:Mesh):Model;
(* Load model from generated mesh (default material) *)

PROCEDURE IsModelReady(model:Model):BOOLEAN;
(* Check if a model is ready *)

PROCEDURE UnloadModel(model:Model);
(* Unload model (including meshes) from memory (RAM and/or VRAM) *)

PROCEDURE GetModelBoundingBox(model:Model):BoundingBox;
(* Compute model bounding box limits (considers all meshes) *)

(* Model drawing PROCEDUREs *)

PROCEDURE DrawModel(model:Model; position:Vector3; scale:Float; tint:Color);
(* Draw a model (with texture if set) *)

PROCEDURE DrawModelEx(model:Model; position:Vector3; rotationAxis:Vector3; rotationAngle:Float; scale:Vector3;
            tint:Color);
(* Draw a model with extended parameters *)

PROCEDURE DrawModelWires(model:Model; position:Vector3; scale:Float; tint:Color);
(* Draw a model wires (with texture if set) *)

PROCEDURE DrawModelWiresEx(model:Model; position:Vector3; rotationAxis:Vector3; rotationAngle:Float; scale:Vector3;
            tint:Color);
(* Draw a model wires (with texture if set) with extended parameters *)

PROCEDURE DrawBoundingBox(box:BoundingBox; color:Color);
(* Draw bounding box (wires) *)

PROCEDURE DrawBillboard(camera:Camera; texture:Texture2D; position:Vector3; size:Float; tint:Color);
(* Draw a billboard texture *)

PROCEDURE DrawBillboardRec(camera:Camera; texture:Texture2D; source:Rectangle; position:Vector3; size:Vector2;
            tint:Color);
(* Draw a billboard texture defined by source *)

PROCEDURE DrawBillboardPro(camera:Camera; texture:Texture2D; source:Rectangle; position:Vector3; up:Vector3;
            size:Vector2; origin:Vector2; rotation:Float; tint:Color);
(* Draw a billboard texture defined by source and rotation *)

(* Mesh management PROCEDUREs *)

PROCEDURE UploadMesh(VAR mesh:Mesh; dynamic:BOOLEAN);
(* Upload mesh vertex data in GPU and provide VAO/VBO ids *)

PROCEDURE UpdateMeshBuffer(mesh:Mesh; index:Int; data:ADDRESS; dataSize:Int; offset:Int);
(* Update mesh vertex data in GPU for a specific buffer index *)

PROCEDURE UnloadMesh(mesh:Mesh);
(* Unload mesh data from CPU and GPU *)

PROCEDURE DrawMesh(mesh:Mesh; material:Material; transform:Matrix);
(* Draw a 3d mesh with material and transform *)

PROCEDURE DrawMeshInstanced(mesh:Mesh; material:Material; transforms:ARRAY OF Matrix; instances:Int);
(* Draw multiple mesh instances with material and different transforms *)

PROCEDURE GetMeshBoundingBox(mesh:Mesh):BoundingBox;
(* Compute mesh bounding box limits *)

PROCEDURE GenMeshTangents(VAR mesh:Mesh);
(* Compute mesh tangents *)

PROCEDURE ExportMesh(mesh:Mesh; fileName:ARRAY OF CHAR):BOOLEAN;
(* Export mesh data to file, returns true on success *)

PROCEDURE ExportMeshAsCode(mesh:Mesh; fileName:ARRAY OF CHAR):BOOLEAN;
(* Export mesh as code file (.h) defining multiple arrays of vertex attributes *)

(* Mesh generation PROCEDUREs *)

PROCEDURE GenMeshPoly(sides:Int; radius:Float):Mesh;
(* Generate polygonal mesh *)

PROCEDURE GenMeshPlane(width:Float; length:Float; resX:Int; resZ:Int):Mesh;
(* Generate plane mesh (with subdivisions) *)

PROCEDURE GenMeshCube(width:Float; height:Float; length:Float):Mesh;
(* Generate cuboid mesh *)

PROCEDURE GenMeshSphere(radius:Float; rings:Int; slices:Int):Mesh;
(* Generate sphere mesh (standard sphere) *)

PROCEDURE GenMeshHemiSphere(radius:Float; rings:Int; slices:Int):Mesh;
(* Generate half-sphere mesh (no bottom cap) *)

PROCEDURE GenMeshCylinder(radius:Float; height:Float; slices:Int):Mesh;
(* Generate cylinder mesh *)

PROCEDURE GenMeshCone(radius:Float; height:Float; slices:Int):Mesh;
(* Generate cone/pyramid mesh *)

PROCEDURE GenMeshTorus(radius:Float; size:Float; radSeg:Int; sides:Int):Mesh;
(* Generate torus mesh *)

PROCEDURE GenMeshKnot(radius:Float; size:Float; radSeg:Int; sides:Int):Mesh;
(* Generate trefoil knot mesh *)

PROCEDURE GenMeshHeightmap(heightmap:Image; size:Vector3):Mesh;
(* Generate heightmap mesh from image data *)

PROCEDURE GenMeshCubicmap(cubicmap:Image; cubeSize:Vector3):Mesh;
(* Generate cubes-based map mesh from image data *)

(* Material loading/unloading PROCEDUREs *)

PROCEDURE LoadMaterials(fileName:ARRAY OF CHAR; VAR materialCount:Int):ADDRESS;
(* Load materials from model file *)

PROCEDURE LoadMaterialDefault():Material;
(* Load default material (Supports: DIFFUSE, SPECULAR, NORMAL maps) *)

PROCEDURE IsMaterialReady(material:Material):BOOLEAN;
(* Check if a material is ready *)

PROCEDURE UnloadMaterial(material:Material);
(* Unload material from GPU memory (VRAM) *)

PROCEDURE SetMaterialTexture(VAR material:Material; mapType:Int; texture:Texture2D);
(* Set texture for a material map type (MATERIAL_MAP_DIFFUSE, MATERIAL_MAP_SPECULAR...) *)

PROCEDURE SetModelMeshMaterial(VAR model:Model; meshId:Int; materialId:Int);
(* Set material for a mesh *)

(* Model animations loading/unloading PROCEDUREs *)

PROCEDURE LoadModelAnimations(fileName:ARRAY OF CHAR; VAR animCount:Int):ADDRESS;
(* Load model animations from file *)

PROCEDURE UpdateModelAnimation(model:Model; anim:ModelAnimation; frame:Int);
(* Update model animation pose *)

PROCEDURE UnloadModelAnimation(anim:ModelAnimation);
(* Unload animation data *)

PROCEDURE UnloadModelAnimations(animations:ARRAY OF ModelAnimation; animCount:Int);
(* Unload animation array data *)

PROCEDURE IsModelAnimationValid(model:Model; anim:ModelAnimation):BOOLEAN;
(* Check model animation skeleton match *)

(* Collision detection PROCEDUREs *)

PROCEDURE CheckCollisionSpheres(center1:Vector3; radius1:Float; center2:Vector3; radius2:Float):BOOLEAN;
(* Check collision between two spheres *)

PROCEDURE CheckCollisionBoxes(box1:BoundingBox; box2:BoundingBox):BOOLEAN;
(* Check collision between two bounding boxes *)

PROCEDURE CheckCollisionBoxSphere(box:BoundingBox; center:Vector3; radius:Float):BOOLEAN;
(* Check collision between box and sphere *)

PROCEDURE GetRayCollisionSphere(ray:Ray; center:Vector3; radius:Float):RayCollision;
(* Get collision info between ray and sphere *)

PROCEDURE GetRayCollisionBox(ray:Ray; box:BoundingBox):RayCollision;
(* Get collision info between ray and box *)

PROCEDURE GetRayCollisionMesh(ray:Ray; mesh:Mesh; transform:Matrix):RayCollision;
(* Get collision info between ray and mesh *)

PROCEDURE GetRayCollisionTriangle(ray:Ray; p1:Vector3; p2:Vector3; p3:Vector3):RayCollision;
(* Get collision info between ray and triangle *)

PROCEDURE GetRayCollisionQuad(ray:Ray; p1:Vector3; p2:Vector3; p3:Vector3; p4:Vector3):RayCollision;
(* Get collision info between ray and quad *)

(*------------------------------------------------------------------------------------ *)

(* Audio Loading and Playing PROCEDUREs (Module: audio) *)

(*------------------------------------------------------------------------------------ *)

(* TYPE *)
(*   (\* AudioCallback = POINTER TO PROCEDURE (bufferData:ADDRESS; frames:Unsigned); *\) *)
(*   AudioCallback = PROCEDURE(bufferData:ADDRESS; frames:Unsigned); *)
(* (\* Audio device management PROCEDUREs *\) *)


PROCEDURE InitAudioDevice;
(* Initialize audio device and context *)

PROCEDURE CloseAudioDevice;
(* Close the audio device and context *)

PROCEDURE IsAudioDeviceReady():BOOLEAN;
(* Check if audio device has been initialized successfully *)

PROCEDURE SetMasterVolume(volume:Float);
(* Set master volume (listener) *)

PROCEDURE GetMasterVolume():Float;
(* Get master volume (listener) *)

(* Wave/Sound loading/unloading PROCEDUREs *)

PROCEDURE LoadWave(fileName:ARRAY OF CHAR):Wave;
(* Load wave data from file *)

PROCEDURE LoadWaveFromMemory(fileType:ARRAY OF CHAR; fileData:ADDRESS; dataSize:Int):Wave;
(* Load wave from memory buffer, fileType refers to extension: i.e. '.wav' *)

PROCEDURE IsWaveReady(wave:Wave):BOOLEAN;
(* Checks if wave data is ready *)

PROCEDURE LoadSound(fileName:ARRAY OF CHAR):Sound;
(* Load sound from file *)

PROCEDURE LoadSoundFromWave(wave:Wave):Sound;
(* Load sound from wave data *)

PROCEDURE LoadSoundAlias(source:Sound):Sound;
(* Create a new sound that shares the same sample data as the source sound, does not own the sound data *)

PROCEDURE IsSoundReady(sound:Sound):BOOLEAN;
(* Checks if a sound is ready *)

PROCEDURE UpdateSound(sound:Sound; data:ADDRESS; sampleCount:Int);
(* Update sound buffer with new data *)

PROCEDURE UnloadWave(wave:Wave);
(* Unload wave data *)

PROCEDURE UnloadSound(sound:Sound);
(* Unload sound *)

PROCEDURE UnloadSoundAlias(alias:Sound);
(* Unload a sound alias (does not deallocate sample data) *)

PROCEDURE ExportWave(wave:Wave; fileName:ARRAY OF CHAR):BOOLEAN;
(* Export wave data to file, returns true on success *)

PROCEDURE ExportWaveAsCode(wave:Wave; fileName:ARRAY OF CHAR):BOOLEAN;
(* Export wave sample data to code (.h), returns true on success *)

(* Wave/Sound management PROCEDUREs *)

PROCEDURE PlaySound(sound:Sound);
(* Play a sound *)

PROCEDURE StopSound(sound:Sound);
(* Stop playing a sound *)

PROCEDURE PauseSound(sound:Sound);
(* Pause a sound *)

PROCEDURE ResumeSound(sound:Sound);
(* Resume a paused sound *)

PROCEDURE IsSoundPlaying(sound:Sound):BOOLEAN;
(* Check if a sound is currently playing *)

PROCEDURE SetSoundVolume(sound:Sound; volume:Float);
(* Set volume for a sound (1.0 is max level) *)

PROCEDURE SetSoundPitch(sound:Sound; pitch:Float);
(* Set pitch for a sound (1.0 is base level) *)

PROCEDURE SetSoundPan(sound:Sound; pan:Float);
(* Set pan for a sound (0.5 is center) *)

PROCEDURE WaveCopy(wave:Wave):Wave;
(* Copy a wave to a new wave *)

PROCEDURE WaveCrop(VAR wave:Wave; initSample:Int; finalSample:Int);
(* Crop a wave to defined samples range *)

PROCEDURE WaveFormat(VAR wave:Wave; sampleRate:Int; sampleSize:Int; channels:Int);
(* Convert wave data to desired format *)

PROCEDURE LoadWaveSamples(wave:Wave):ADDRESS;
(* Load samples data from wave as a 32bit float data array *)

PROCEDURE UnloadWaveSamples(samples:ARRAY OF Float);
(* Unload samples data loaded with LoadWaveSamples() *)

(* Music management PROCEDUREs *)

PROCEDURE LoadMusicStream(fileName:ARRAY OF CHAR):Music;
(* Load music stream from file *)

PROCEDURE LoadMusicStreamFromMemory(fileType:ARRAY OF CHAR; data:ADDRESS; dataSize:Int):Music;
(* Load music stream from data *)

PROCEDURE IsMusicReady(music:Music):BOOLEAN;
(* Checks if a music stream is ready *)

PROCEDURE UnloadMusicStream(music:Music);
(* Unload music stream *)

PROCEDURE PlayMusicStream(music:Music);
(* Start music playing *)

PROCEDURE IsMusicStreamPlaying(music:Music):BOOLEAN;
(* Check if music is playing *)

PROCEDURE UpdateMusicStream(music:Music);
(* Updates buffers for music streaming *)

PROCEDURE StopMusicStream(music:Music);
(* Stop music playing *)

PROCEDURE PauseMusicStream(music:Music);
(* Pause music playing *)

PROCEDURE ResumeMusicStream(music:Music);
(* Resume playing paused music *)

PROCEDURE SeekMusicStream(music:Music; position:Float);
(* Seek music to a position (in seconds) *)

PROCEDURE SetMusicVolume(music:Music; volume:Float);
(* Set volume for music (1.0 is max level) *)

PROCEDURE SetMusicPitch(music:Music; pitch:Float);
(* Set pitch for a music (1.0 is base level) *)

PROCEDURE SetMusicPan(music:Music; pan:Float);
(* Set pan for a music (0.5 is center) *)

PROCEDURE GetMusicTimeLength(music:Music):Float;
(* Get music time length (in seconds) *)

PROCEDURE GetMusicTimePlayed(music:Music):Float;
(* Get current music time played (in seconds) *)

(* AudioStream management PROCEDUREs *)

PROCEDURE LoadAudioStream(sampleRate:Unsigned; sampleSize:Unsigned; channels:Unsigned):AudioStream;
(* Load audio stream (to stream raw audio pcm data) *)

PROCEDURE IsAudioStreamReady(stream:AudioStream):BOOLEAN;
(* Checks if an audio stream is ready *)

PROCEDURE UnloadAudioStream(stream:AudioStream);
(* Unload audio stream and free memory *)

PROCEDURE UpdateAudioStream(stream:AudioStream; data:ADDRESS; frameCount:Int);
(* Update audio stream buffers with data *)

PROCEDURE IsAudioStreamProcessed(stream:AudioStream):BOOLEAN;
(* Check if any audio stream buffers requires refill *)

PROCEDURE PlayAudioStream(stream:AudioStream);
(* Play audio stream *)

PROCEDURE PauseAudioStream(stream:AudioStream);
(* Pause audio stream *)

PROCEDURE ResumeAudioStream(stream:AudioStream);
(* Resume audio stream *)

PROCEDURE IsAudioStreamPlaying(stream:AudioStream):BOOLEAN;
(* Check if audio stream is playing *)

PROCEDURE StopAudioStream(stream:AudioStream);
(* Stop audio stream *)

PROCEDURE SetAudioStreamVolume(stream:AudioStream; volume:Float);
(* Set volume for audio stream (1.0 is max level) *)

PROCEDURE SetAudioStreamPitch(stream:AudioStream; pitch:Float);
(* Set pitch for audio stream (1.0 is base level) *)

PROCEDURE SetAudioStreamPan(stream:AudioStream; pan:Float);
(* Set pan for audio stream (0.5 is centered) *)

PROCEDURE SetAudioStreamBufferSizeDefault(size:Int);
(* Default size for new audio streams *)

PROCEDURE SetAudioStreamCallback(stream:AudioStream; callback:AudioCallback);
(* Audio thread callback to request new data *)

PROCEDURE AttachAudioStreamProcessor(stream:AudioStream; processor:AudioCallback);
(* Attach audio stream processor to stream, receives the samples as <float>s *)

PROCEDURE DetachAudioStreamProcessor(stream:AudioStream; processor:AudioCallback);
(* Detach audio stream processor from stream *)

PROCEDURE AttachAudioMixedProcessor(processor:AudioCallback);
(* Attach audio stream processor to the entire audio pipeline, receives the samples as <float>s *)

PROCEDURE DetachAudioMixedProcessor(processor:AudioCallback);
(* Detach audio stream processor from the entire audio pipeline *)

END raylib.
